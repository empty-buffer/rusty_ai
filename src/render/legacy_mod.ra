// fn draw_content_to_buffer(editor: &mut Editor, render_state: &mut RenderState) -> Result<()> {
//     let content = editor.get_content();
//     let viewport_height = render_state.term_height as usize - 2;
//     let line_number_width = render_state.line_number_width;

//     let selection_range = editor.get_selection_range();

//     // Get all visible lines
//     let visible_lines: Vec<&str> = content
//         .lines()
//         .skip(render_state.scroll_offset)
//         .take(viewport_height)
//         .collect();

//     // Pre-calculate line start indices
//     let mut line_start_indices = Vec::with_capacity(visible_lines.len());
//     let mut current_index = 0;

//     for line_idx in 0..render_state.scroll_offset {
//         if let Some(line) = content.lines().nth(line_idx) {
//             current_index += line.len() + 1; // +1 for newline
//         }
//     }

//     for line in &visible_lines {
//         line_start_indices.push(current_index);
//         current_index += line.len() + 1; // +1 for newline
//     }

//     // for (i, _) in visible_lines.iter().enumerate() {
//     //     let real_line_number = i + render_state.scroll_offset;
//     //     // Highlight the line if it's not cached or is marked dirty
//     //     if !editor.syntax_cache_is_line_cached(real_line_number) {
//     //         editor.highlight_line(real_line_number);
//     //     }
//     // }

//     // Draw each visible line
//     for (i, line) in visible_lines.iter().enumerate() {
//         let row = i;
//         let real_line_number = i + render_state.scroll_offset + 1;
//         // Draw line number
//         let line_num_str = format!("{:>width$} ", real_line_number, width = line_number_width);
//         for (x, ch) in line_num_str.chars().enumerate() {
//             render_state.set_cell(x, row, ch, Color::DarkGrey, None);
//         }

//         // Draw the actual line content with syntax highlighting
//         let line_start_char_idx = line_start_indices[i];
//         let max_line_width = render_state.term_width as usize - line_number_width - 1;
//         let mut displayed_width = 0;
//         let mut col = line_number_width + 1;

//         // Process each character in the line with its style
//         for (char_col, ch) in line.chars().enumerate() {
//             // let actual_char_idx = line_start_char_idx + char_idx;
//             let actual_row = row + render_state.scroll_offset;
//             //
//             let style = if editor.is_position_selected(actual_row, char_col, &selection_range) {
//                 Style::Selection
//             } else if let Some(cached_style) =
//                 editor.get_syntax_cache_cached_style(actual_row, char_col)
//             {
//                 cached_style
//             } else {
//                 let char_idx = line_start_indices[i] + char_col;
//                 editor.get_style_at(char_idx)
//             };
//             // Set color based on style
//             let (fg_color, bg_color) = match style {
//                 Style::Normal => (Color::White, None),
//                 Style::Keyword => (Color::Magenta, None),
//                 Style::Function => (Color::Blue, None),
//                 Style::Type => (Color::Cyan, None),
//                 Style::String => (Color::Green, None),
//                 Style::Number => (Color::Yellow, None),
//                 Style::Comment => (Color::DarkGrey, None),
//                 Style::Variable => (Color::White, None),
//                 Style::Constant => (Color::Yellow, None),
//                 Style::Operator => (Color::White, None),
//                 Style::Selection => (Color::Black, Some(Color::Grey)),
//                 Style::Error => (Color::Red, Some(Color::White)),
//             };

//             // Handle tab and width calculations
//             let width = if ch == '\t' {
//                 4 - (displayed_width % 4) // Tab stops every 4 spaces
//             } else {
//                 1
//             };

//             if displayed_width + width > max_line_width {
//                 break;
//             }

//             // Add character to buffer
//             if ch == '\t' {
//                 for _ in 0..width {
//                     render_state.set_cell(col, row, ' ', fg_color, bg_color);
//                     col += 1;
//                 }
//             } else {
//                 render_state.set_cell(col, row, ch, fg_color, bg_color);
//                 col += 1;
//             }

//             displayed_width += width;
//         }
//     }

//     Ok(())
// }
